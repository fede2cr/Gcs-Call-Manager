db.events.find({}, { students : 
                    { $elemMatch : 
                       { id : ObjectId("51780f796ec4051a536015d0"), 
                         name : "Sam" 
                       } 
                    } 
                } 
);

db.events.find({channel : {'$regex': /SIP/}}, {events : { '$elemMatch' : { status : 'Ringing' }}})

db.events.find({channel : {'$regex': /SIP/}, events : { '$elemMatch' : { $and : [ {status : 'Ringing'}, {status : 'Up'} ] } } } , { "events.status": 1})

db.events.find({channel : {'$regex': /SIP/},events : { '$elemMatch' : { status : 'Ringing' }}}, { "events.status": 1})

db.events.find({channel : {'$regex': /SIP/},$and : [events : { '$elemMatch' : { status : 'Ringing' }}, events : { '$elemMatch' : { status : { $ne : 'Up'} }}]}, { "events.status": 1})

"carrier.state": { $ne: "NY" }
db.events.find({channel : {'$regex': /SIP/}, 'events.status': { '$ne' : 'Up'}, events : { '$elemMatch' : { status : 'Ringing' }}}, { "events.status": 1})


db.events.find({channel : {'$regex': /SIP/}, '$and' : [ {'events.status': { '$ne' : 'Up'}}, {'events.status' : 'Ringing'}, {'events.name' : 'Hangup'}, {'events.epoch': {'$gte' : '1435093594'} } ] }, { "events.status": 1})


db.queues.insert({epoch: '1438098566', queues: [{abandoned : 0, name: 500}, {abandoned : 0, name: 501}, {abandoned : 0, name: 502}, {abandoned : 0, name: 503}, {abandoned : 0, name: 504}, {abandoned : 0, name: 505}]})

db.queues.update({ '_id': ObjectId("559d99df86670cf632610297")}, { '$set' : {queues: [{abandoned : 0, name: 500}, {abandoned : 0, name: 501}, {abandoned : 0, name: 502}, {abandoned : 0, name: 503}, {abandoned : 0, name: 504}, {abandoned : 3, name: 505}]}})



db.events.find({'channel': {'$regex': /SIP/}, 'connectedlinename': {'$regex': '/RE/'}, '$and': [{'events.status': {'$ne': 'Up'}}, {'events.status': 'Ringing'}, {'events.name': 'Hangup'}]})


db.pauses.find({ '$or' : [ {'agent': '1005'}, {'agent' : '1015'} ] }).pretty()


	Github
		- Usuario : greencorecr
		- Clave : ahVeing9Xei9eilo



	TODO

		* si la cola es dinámica debe guardar como deserción con la hora de la salida de la cola.
		- Si se promedia el  tiempo de labores, debe guardarse el tiempo de log in y log off.
			* si es estática se debe registrar en algún lado de la app los tiempos de jornada.

		>>>> Los reportes deben ser en tiempo real?


		ERROR MONGO
			MongoError: Runner error: Overflow sort stage buffered data usage of 35495268 bytes exceeds internal limit 
			of 33554432 bytes] name: 'MongoError'
			Después de borrar los eventos ya no pega la terminal!! El Collection de eventos tenía 2006 archivos.